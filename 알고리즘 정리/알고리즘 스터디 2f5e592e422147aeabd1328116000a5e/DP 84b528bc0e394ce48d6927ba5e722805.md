# DP

## 정의

---

> DP( Dynamic Programming), dp는 **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법,** 또한 **큰 문제를 작은 문제로 나눠서 푸는 알고리즘**
> 

## 문제 유형

---

1. 최적 부분 구조
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결
2. 중복되는 부분 문제
    - 동일하게 반복되는 작은 문제로 해결
    

## DP 문제 해결법

---

1. 주어진 문제가 DP 문제 유형인지 생각하고 최종적으로 구할 큰 문제가 뭔지 확인한다.
2. 작은 문제들과 큰 문제 사이의 관계를 점화식의 형태로 나타낸다.
3. top-down 방식 혹은 bottom-up 방식을 통해 문제를 풀어나간다.

## 메모이제이션(Memoization)

---

- 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나
- 한 번 계산한 결과를 말 그대로 메모리 공간에 메모하는 기법
    - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
    - 갑을 기록해 놓는다는 점에서 캐싱이라고도 한다.
- 메모이제이션은 한 번 구한 정보를 리스트에 저장하는 형태로 구현 가능
    - 리스트를 보통 DP테이블 또는 동적 테이블 이라고 한다.
    

## top-down vs bottom-up

---

- top-down 방식은 재귀함수로 구현할 수 있고, bottom-up 방식은 반복문으로 구현
- 다이나믹 프로그래밍의 전형적인 형태는 bottom-up 방식
- 일반적으로 재귀함수를 사용하는 것 보다 반복문을 사용하는 것이 성능이 좀 더 좋다(오버헤드가 줄기 때문에). 시간 복잡도 측면에서는 동일

## 동적 계획법을 그래프로 모델화 하기

---

- 동적 계획법은 대부분 **그래프**, 그 중에서도 **사이클이 없는 유향 그래프(DAG)**로 모델화 가능
    - 정점: 문제에서의 특정 상황을 유일하게 결정지을 수 있는 변수들로 이루어진 **상태**
    - 간선: 상태간의 전이를 나타내는 **점화식**
    - 각 정점은 자신의 상태에 대한 답을 가짐
- 점화식 세우기
    - 변수가 항상 감소 / 항상 증가하는 상태에서만 가져오는 경우
        - `dp[i]=max1<j<idp[j]+C[i]` `dp[i]=max1<j<idp[j]+C[i]`와 같은 것이 있으며,
        - `j<i` `j<i`인 j들로부터만 상태에 대한 답을 가져오므로 사이클이 형성되지
    - 변수들의 합 / 차가 항상 감소 / 항상 증가하는 상태에서만 가져오는 경우
        - `dp[s][e]=max(dp[s+1][e]`,`dp[s][e−1])+C[s][e]`
        - `dp[s][e]=max(dp[s+1][e],dp[s][e−1])+C[s][e]`와 같이 범위를 변수로 가지는 경우에 자주 사용

## 예시

---

[피보나치 수열](DP%2084b528bc0e394ce48d6927ba5e722805/%E1%84%91%E1%85%B5%E1%84%87%E1%85%A9%E1%84%82%E1%85%A1%E1%84%8E%E1%85%B5%20%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A7%E1%86%AF%20269ed06cb4394df38d68ca53e7b44b2d.md)